## Ormin -- ORM for Nim.
## (c) 2017 Andreas Rumpf
## MIT License.

import parsesql, streams, strutils, os, parseopt, tables
import db_connector/db_common

# Enhanced SQL parsing with PRAGMA support using nkCall nodes
type
  EnhancedSqlParser* = object
    pragmas*: seq[SqlNode]  # pragma statements as nkCall nodes
    sqlAst*: SqlNode

#import compiler / [ast, renderer]

const
  FileHeader = """
# Generated by ormin_importer. DO NOT EDIT.

type
  Attr = object
    name: string
    tabIndex: int
    typ: DbTypekind
    key: int   # 0 nothing special,
               # +1 -- primary key
               # -N -- references attribute N
"""

proc writeHelp() =
  echo """
ormin <schema.sql> --out:<file.nim>  --db:postgre|sqlite|mysql
"""

proc writeVersion() = echo "v1.0"

type
  DbColumn* = object   ## information about a database column
    name*: string      ## name of the column
    tableName*: string ## name of the table the column belongs to (optional)
    typ*: DbType       ## type of the column
    primaryKey*: bool  ## is this a primary key?
    refs*: (string, string)  ## is this a foreign key?
  DbColumns* = seq[DbColumn]

  KnownTables = OrderedTable[string, DbColumns]
  Target = enum
    postgre, sqlite, mysql

proc hasAttribute(colDesc: SqlNode; k: set[SqlNodeKind]): bool =
  for i in 2..<colDesc.len:
    if colDesc[i].kind in k: return true

proc hasRefs(colDesc: SqlNode): (string, string) =
  for i in 2..<colDesc.len:
    let c = colDesc[i]
    if c.kind == nkReferences:
      if c[0].kind == nkCall:
        return (c[0][0].strVal, c[0][1].strVal)
      elif c[0].kind == nkIdent:
        # assume 'references(id)'
        return ($c[0], "id")
      else:
        discard
  return ("", "")

proc getType(n: SqlNode): DbType =
  var it = n
  if it.kind == nkCall: it = it[0]
  if it.kind == nkEnumDef:
    result.kind = dbEnum
    result.validValues = @[]
    for i in 0..<it.len:
      assert it[i].kind == nkStringLit
      result.validValues.add it[i].strVal
  elif it.kind in {nkIdent, nkStringLit}:
    var k = dbUnknown
    case it.strVal.toLowerAscii
    of "int", "integer", "int8", "smallint", "int16",
       "longint", "int32", "int64", "tinyint", "hugeint": k = dbInt
    of "uint", "uint8", "uint16", "uint32", "uint64": k = dbUInt
    of "serial": k = dbSerial
    of "bit": k = dbBit
    of "bool", "boolean": k = dbBool
    of "blob": k = dbBlob
    of "fixedchar": k = dbFixedChar
    of "varchar", "text", "string": k = dbVarchar
    of "json": k = dbJson
    of "xml": k = dbXml
    of "decimal": k = dbDecimal
    of "float", "double", "longdouble", "real": k = dbFloat
    of "date", "day": k = dbDate
    of "time": k = dbTime
    of "datetime": k = dbDateTime
    of "timestamp", "timestamptz": k = dbTimestamp
    of "timeinterval": k = dbTimeInterval
    of "set": k = dbSet
    of "array": k = dbArray
    of "composite": k = dbComposite
    of "url", "uri": k = dbUrl
    of "uuid": k = dbUuid
    of "inet", "ip", "tcpip": k = dbInet
    of "mac", "macaddress": k = dbMacAddress
    of "geometry": k = dbGeometry
    of "point": k = dbPoint
    of "line": k = dbLine
    of "lseg": k = dbLseg
    of "box": k = dbBox
    of "path": k = dbPath
    of "polygon": k = dbPolygon
    of "circle": k = dbCircle
    else: discard
    result.kind = k
    result.name = it.strVal

proc collectTables(n: SqlNode; t: var KnownTables) =
  if n.isNil: return
  case n.kind
  of nkCall:
    # Handle pragma statements (nkCall nodes with "pragma" as function name)
    if n.len >= 1 and n[0].kind == nkIdent and n[0].strVal.toLowerAscii == "pragma":
      # Ignore pragma statements - they're handled separately
      return
    else:
      # Handle other call nodes by recursing into children
      for i in 0..<n.len: collectTables(n[i], t)
  of nkCreateTable, nkCreateTableIfNotExists:
    let tableName = n[0].strVal
    var cols: DbColumns = @[]
    for i in 1..<n.len:
      let it = n[i]
      if it.kind == nkColumnDef:
        var typ = getType(it[1])
        if hasAttribute(it, {nkNotNull}):
          typ.notNull = true
        cols.add DbColumn(name: it[0].strVal, tableName: tableName,
                          typ: typ,
                          primaryKey: hasAttribute(it, {nkPrimaryKey}),
                          refs: hasRefs(it))
    for i in 1..<n.len:
      let it = n[i]
      if it.kind == nkForeignKey:
        var r = it[1]
        doAssert r.kind == nkReferences
        r = r[0]
        doAssert r.kind == nkCall
        for c in mitems(cols):
          if cmpIgnoreCase(c.name, it[0].strVal) == 0:
            c.refs = (r[0].strVal, r[1].strVal)
            break
    t[tablename] = cols
  else:
    for i in 0..<n.len: collectTables(n[i], t)

proc attrToKey(a: DbColumn; t: KnownTables): int =
  if a.primaryKey: return 1
  if a.refs[0].len > 0:
    var i = 0
    for k, v in pairs(t):
      for b in v:
        if cmpIgnoreCase(k, a.refs[0]) == 0 and cmpIgnoreCase(b.name, a.refs[1]) == 0:
          return -i - 1
        inc i
  result = 0

proc parsePragmaStatement(line: string): SqlNode =
  ## Parse a pragma statement into an nkCall AST node
  let trimmed = line.strip()
  let parts = trimmed.split(Whitespace, maxsplit = 2)
  
  if parts.len >= 2:
    # Create nkCall node with "pragma" as the function name
    result = newNode(nkCall)
    result.add(newNode(nkIdent, "pragma"))
    
    # Add the pragma name as first argument
    let pragmaName = parts[1]
    result.add(newNode(nkIdent, pragmaName))
    
    if parts.len >= 3:
      # Handle "pragma name = value" format
      let valueStr = parts[2]
      if "=" in valueStr:
        let valueParts = valueStr.split("=", maxsplit = 1)
        if valueParts.len == 2:
          let value = valueParts[1].strip()
          # Remove semicolon and quotes if present
          let cleanValue = value.strip(chars = {';', ' ', '"', '\''})
          result.add(newNode(nkStringLit, cleanValue))
        else:
          result.add(newNode(nkStringLit, ""))
      else:
        # Value without equals (e.g., "pragma optimize;")
        let cleanValue = valueStr.strip(chars = {';', ' '})
        if cleanValue.len > 0:
          result.add(newNode(nkStringLit, cleanValue))
  else:
    # Fallback: create a simple pragma call
    result = newNode(nkCall)
    result.add(newNode(nkIdent, "pragma"))

proc parseEnhancedSql*(content: string, filename: string): EnhancedSqlParser =
  ## Enhanced SQL parser that handles PRAGMA statements as nkCall nodes
  result.pragmas = @[]
  
  var sqlLines: seq[string] = @[]
  
  # First pass: extract pragma statements and build clean SQL
  for line in content.splitLines():
    let trimmed = line.strip()
    if trimmed.toLowerAscii.startsWith("pragma"):
      # Parse and store pragma statement as nkCall AST node
      let pragmaNode = parsePragmaStatement(line)
      result.pragmas.add(pragmaNode)
      # Replace with empty line to maintain line numbers for error reporting
      sqlLines.add("")
    else:
      sqlLines.add(line)
  
  # Second pass: parse the clean SQL with standard parsesql
  let cleanSql = sqlLines.join("\n")
  let stream = newStringStream(cleanSql)
  if stream.isNil:
    quit "fatal: cannot create stream for " & filename
  
  result.sqlAst = parseSql(stream, filename)
  stream.close()
  
  # Third pass: integrate pragma nodes into the main AST
  # Add pragma nodes to the beginning of the statement list
  if result.sqlAst.kind == nkStmtList and result.pragmas.len > 0:
    # Create a new statement list with pragmas first
    let newStmtList = newNode(nkStmtList)
    # Add all pragma statements first
    for pragma in result.pragmas:
      newStmtList.add(pragma)
    # Then add all original SQL statements
    for i in 0..<result.sqlAst.len:
      newStmtList.add(result.sqlAst[i])
    result.sqlAst = newStmtList

proc generateCode(infile, outfile: string; target: Target) =
  let content = readFile(infile)
  let parser = parseEnhancedSql(content, infile)
  
  # Log detected pragmas (optional)
  when defined(debugOrmin):
    for pragma in parser.pragmas:
      if pragma.kind == nkCall and pragma.len >= 2:
        let pragmaName = if pragma[1].kind == nkIdent: pragma[1].strVal else: "unknown"
        let pragmaValue = if pragma.len >= 3 and pragma[2].kind == nkStringLit: pragma[2].strVal else: ""
        echo "Detected pragma: ", pragmaName, " = ", pragmaValue
  
  var knownTables = initOrderedTable[string, DbColumns]()
  collectTables(parser.sqlAst, knownTables)
  var f: File
  if open(f, outfile, fmWrite):
    f.write FileHeader
    f.write "const tableNames = ["
    var i = 0
    for k in keys(knownTables):
      if i > 0: f.write ",\L  "
      else: f.write "\L  "
      f.write(escape(k))
      inc i
    f.write "\L]\L"
    i = 0
    var j = 0
    f.write "\Lconst attributes = ["
    for k, v in mpairs(knownTables):
      for a in v:
        if j > 0: f.write ",\L  "
        else: f.write "\L  "
        f.write "Attr(name: ", escape(a.name), ", tabIndex: ", $i,
                ", typ: ", $a.typ.kind, ", key: ", $attrToKey(a, knownTables), ")"
        inc j
      inc i
    f.write "\L]\L"
    close(f)

var p = initOptParser()
var infile = ""
var outfile = ""
var target: Target
for kind, key, val in p.getopt():
  case kind
  of cmdArgument:
    infile = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
    of "out", "o": outfile = val
    of "db": target = parseEnum[Target](val)
    else: discard
  of cmdEnd: assert(false) # cannot happen
if infile == "":
  # no filename has been given, so we show the help:
  writeHelp()
else:
  if outfile == "":
    outfile = changeFileExt(infile, "nim")
  generateCode(infile, outfile, target)
