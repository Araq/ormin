## Ormin -- ORM for Nim.
## (c) 2017 Andreas Rumpf
## MIT License.

import streams, strutils, os, parseopt, tables
import db_connector/db_common

import ../ormin/db_types
import ../ormin/parsesql_tmp

#import compiler / [ast, renderer]

const
  FileHeader = """
# Generated by ormin_importer. DO NOT EDIT.

type
  Attr = object
    name: string
    tabIndex: int
    typ: DbTypekind
    key: int   # 0 nothing special,
               # +1 -- primary key
               # -N -- references attribute N
"""

proc writeHelp() =
  echo """
ormin <schema.sql> --out:<file.nim>  --db:postgre|sqlite|mysql
"""

proc writeVersion() = echo "v1.0"

type
  DbColumn* = object   ## information about a database column
    name*: string      ## name of the column
    tableName*: string ## name of the table the column belongs to (optional)
    typ*: DbType       ## type of the column
    primaryKey*: bool  ## is this a primary key?
    refs*: (string, string)  ## is this a foreign key?
  DbColumns* = seq[DbColumn]

  KnownTables = OrderedTable[string, DbColumns]
  Target = enum
    postgre, sqlite, mysql

proc hasAttribute(colDesc: SqlNode; k: set[SqlNodeKind]): bool =
  for i in 2..<colDesc.len:
    if colDesc[i].kind in k: return true

proc hasRefs(colDesc: SqlNode): (string, string) =
  for i in 2..<colDesc.len:
    let c = colDesc[i]
    if c.kind == nkReferences:
      if c[0].kind == nkCall:
        return (c[0][0].strVal, c[0][1].strVal)
      elif c[0].kind == nkIdent:
        # assume 'references(id)'
        return ($c[0], "id")
      else:
        discard
  return ("", "")

proc getType(n: SqlNode): DbType =
  var it = n
  if it.kind == nkCall: it = it[0]
  if it.kind == nkEnumDef:
    result.kind = dbEnum
    result.validValues = @[]
    for i in 0..<it.len:
      assert it[i].kind == nkStringLit
      result.validValues.add it[i].strVal
  elif it.kind in {nkIdent, nkStringLit}:
    result.kind = dbTypFromName(it.strVal)
    result.name = it.strVal

proc collectTables(n: SqlNode; t: var KnownTables) =
  if n.isNil: return
  case n.kind
  of nkCreateTable, nkCreateTableIfNotExists:
    let tableName = n[0].strVal
    var cols: DbColumns = @[]
    for i in 1..<n.len:
      let it = n[i]
      if it.kind == nkColumnDef:
        var typ = getType(it[1])
        if hasAttribute(it, {nkNotNull}):
          typ.notNull = true
        cols.add DbColumn(name: it[0].strVal, tableName: tableName,
                          typ: typ,
                          primaryKey: hasAttribute(it, {nkPrimaryKey}),
                          refs: hasRefs(it))
    # Handle table-level foreign keys, including composite FKs
    for i in 1..<n.len:
      let it = n[i]
      if it.kind == nkForeignKey:
        # nkForeignKey children layout (from parser):
        #   - one or more nkIdent nodes for local columns
        #   - one nkReferences node containing a nkColumnReference
        var refNode: SqlNode = nil
        var localCols: seq[string] = @[]
        for j in 0..<it.len:
          let child = it[j]
          if child.kind == nkReferences:
            refNode = child
          elif child.kind == nkIdent:
            localCols.add(child.strVal)
        if refNode.isNil: continue
        var r = refNode[0]
        # r can be nkColumnReference(table, col1, col2, ...) or a simple call
        var refTable = ""
        var refCols: seq[string] = @[]
        if r.kind == nkColumnReference or r.kind == nkCall:
          # first child is the table name
          refTable = r[0].strVal
          for k in 1..<r.len:
            refCols.add(r[k].strVal)
        # Map each local column to corresponding referenced column
        let pairCount = min(localCols.len, refCols.len)
        for k in 0..<pairCount:
          let localName = localCols[k]
          let targetCol = refCols[k]
          for c in mitems(cols):
            if cmpIgnoreCase(c.name, localName) == 0:
              c.refs = (refTable, targetCol)
              break
    t[tablename] = cols
  else:
    for i in 0..<n.len: collectTables(n[i], t)

proc attrToKey(a: DbColumn; t: KnownTables): int =
  if a.primaryKey: return 1
  if a.refs[0].len > 0:
    var i = 0
    for k, v in pairs(t):
      for b in v:
        if cmpIgnoreCase(k, a.refs[0]) == 0 and cmpIgnoreCase(b.name, a.refs[1]) == 0:
          return -i - 1
        inc i
  result = 0

proc generateCode(infile, outfile: string; target: Target) =
  let stream = newFileStream(infile, fmRead)
  if stream.isNil:
    quit "fatal: cannot open " & infile
  let sql = parseSql(stream, infile)
  var knownTables = initOrderedTable[string, DbColumns]()
  collectTables(sql, knownTables)
  var f: File
  if open(f, outfile, fmWrite):
    f.write FileHeader
    f.write "const tableNames = ["
    var i = 0
    for k in keys(knownTables):
      if i > 0: f.write ",\L  "
      else: f.write "\L  "
      f.write(escape(k.toLowerAscii))
      inc i
    f.write "\L]\L"
    i = 0
    var j = 0
    f.write "\Lconst attributes = ["
    for k, v in mpairs(knownTables):
      for a in v:
        if j > 0: f.write ",\L  "
        else: f.write "\L  "
        f.write "Attr(name: ", escape(a.name.toLowerAscii), ", tabIndex: ", $i,
                ", typ: ", $a.typ.kind, ", key: ", $attrToKey(a, knownTables), ")"
        inc j
      inc i
    f.write "\L]\L"
    close(f)

var p = initOptParser()
var infile = ""
var outfile = ""
var target: Target
for kind, key, val in p.getopt():
  case kind
  of cmdArgument:
    infile = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
    of "out", "o": outfile = val
    of "db": target = parseEnum[Target](val)
    else: discard
  of cmdEnd: assert(false) # cannot happen
if infile == "":
  # no filename has been given, so we show the help:
  writeHelp()
else:
  if outfile == "":
    outfile = changeFileExt(infile, "nim")
  generateCode(infile, outfile, target)
